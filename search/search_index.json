{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OMOP Alchemy","text":"<p>OMOP Alchemy provides a canonical, typed, SQLAlchemy-first representation of the OHDSI OMOP Common Data Model (CDM).</p> <p>It is designed for research-ready analytics, validation, and exploration.</p>"},{"location":"#where-omop-alchemy-fits","title":"Where OMOP Alchemy fits","text":"<p>OMOP Alchemy sits between raw OMOP databases and exploratory analytics, validation, and research tooling</p> <p>It provides:</p> <ul> <li>stable ORM models</li> <li>explicit relationships</li> <li>safe, inspectable abstractions</li> </ul> <p>without imposing workflow assumptions.</p>"},{"location":"#whats-in-this-documentation","title":"What\u2019s in this documentation","text":""},{"location":"#getting-started","title":"Getting started","text":"<p>How to install OMOP Alchemy, create sessions, and start querying safely.</p> <ul> <li>Installation</li> <li>Quickstart</li> <li>Sessions &amp; engines</li> </ul>"},{"location":"#omop-cdm-models","title":"OMOP CDM models","text":"<p>Typed ORM models corresponding to the official OMOP CDM tables, organised by clinical and operational domain.</p> <ul> <li>CDM overview</li> <li>Clinical models</li> <li>Health system models</li> <li>Vocabulary &amp; concepts</li> <li>Derived models</li> <li>Structural tables</li> <li>Unstructured data</li> <li>Health economic data</li> <li>Metadata</li> </ul>"},{"location":"#validation-semantics","title":"Validation &amp; semantics","text":"<p>Object- and model-level validation utilities that help maintain semantic clarity during analysis.</p> <ul> <li>Validation overview</li> <li>Domain rules</li> <li>Runtime domain checking</li> </ul>"},{"location":"#advanced-usage","title":"Advanced usage","text":"<p>Patterns and techniques for more complex analytical work.</p> <ul> <li>Views</li> <li>Timelines &amp; longitudinal analysis</li> <li>Query patterns</li> <li>Backend considerations</li> </ul>"},{"location":"#api-reference","title":"API reference","text":"<p>Low-level primitives and decorators used throughout the library.</p> <ul> <li>Base classes</li> <li>Columns &amp; mixins</li> <li>Typing helpers</li> </ul>"},{"location":"#example","title":"Example","text":"<pre><code>from omop_alchemy.cdm.model.vocabulary import ConceptView\n\nconcept = session.get(ConceptView, 320128)\nconcept.domain.domain_id\nconcept.vocabulary.vocabulary_id\nconcept.is_standard\n</code></pre>"},{"location":"#status","title":"Status","text":"<p>OMOP Alchemy is currently beta. The core model surface is stabilising; feedback is welcome.</p>"},{"location":"advanced/","title":"Advanced Usage","text":"<p>This section covers higher-level patterns built on top of the core OMOP models.</p> <p>These features enable rich analytics and longitudinal reasoning while preserving the immutability and interpretability of the underlying CDM tables.</p>"},{"location":"advanced/#read-only-views","title":"Read-Only Views","text":"<ul> <li>Views</li> </ul>"},{"location":"advanced/#timelines-longitudinal-analysis","title":"Timelines &amp; Longitudinal Analysis","text":"<ul> <li>Event Timelines</li> </ul>"},{"location":"advanced/#backend-performance-notes","title":"Backend &amp; Performance Notes","text":"<ul> <li>Backend Compatibility</li> <li>Query Patterns</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This section documents the core authoring primitives used to define OMOP CDM models in OMOP Alchemy.</p> <p>These APIs are intentionally low-level, explicit, and composable. They are designed for model authors, not end-users or analysts.</p> <p>If you are:</p> <ul> <li>defining new OMOP CDM tables or views</li> <li>extending the model surface</li> <li>encoding structural or semantic conventions</li> <li>building derived or analytical layers</li> </ul> <p>\u2026this is the layer you will work with most directly.</p> Section Purpose Base tables Core base classes and inheritance structure Columns Reusable column helpers and FK patterns Mixins Structural mixins encoding OMOP table semantics Typing Protocols for static typing and semantic contracts <p>The APIs documented here follow a few consistent principles:</p> <ul> <li> <p>No hidden behavior   Nothing creates engines, sessions, or tables implicitly.</p> </li> <li> <p>Declarative first   Structure and intent should be visible directly on the model class.</p> </li> <li> <p>Structural, not analytical   These tools encode what a table is, not how it is used.</p> </li> <li> <p>Safe to import anywhere   All modules are import-safe and side-effect free.</p> </li> </ul> <p>This makes the API suitable for: - schema inspection - validation tooling - static analysis - documentation generation - interactive exploration</p>"},{"location":"api/#architecture","title":"Architecture","text":"<p>Layered architecture specification is described in Architecture</p>"},{"location":"api/#base-table-infrastructure","title":"Base table infrastructure","text":"<p>At the core of OMOP Alchemy is a small number of base classes that define what it means to be a CDM table.</p> <p>These classes integrate with lower-level infrastructure (i.e. <code>orm-loader</code>) but remain OMOP-specific.</p> <p>Base tables</p>"},{"location":"api/#column-helpers","title":"Column helpers","text":"<p>OMOP CDM tables repeat a number of column patterns: concept foreign keys, nullable vs required fields, source attribution, etc.</p> <p>Column helpers provide named, intention-revealing shortcuts for these patterns.</p> <p>Column helpers</p>"},{"location":"api/#structural-mixins","title":"Structural mixins","text":"<p>Many OMOP tables share structural semantics:</p> <ul> <li>person-scoped records</li> <li>dated events</li> <li>value-typed observations</li> <li>unit concepts</li> <li>health system attribution</li> </ul> <p>Mixins encode these patterns once, and make them reusable and inspectable.</p> <p>Column mixins</p>"},{"location":"api/#typing-and-semantic-contracts","title":"Typing and semantic contracts","text":"<p>OMOP Alchemy makes heavy use of Python typing to express semantic expectations:</p> <ul> <li>\u201cthis object has a concept_id\u201d</li> <li>\u201cthis table participates in domain validation\u201d</li> <li>\u201cthis is a clinical event\u201d</li> </ul> <p>These protocols support: - static type checking - IDE assistance - tooling and validation layers</p> <p>Typing protocols</p>"},{"location":"api/#relationship-to-other-layers","title":"Relationship to other layers","text":"<p>This API layer sits above generic ORM infrastructure and below analytical or validation tooling.</p> Layer Responsibility Database Physical storage, constraints orm-loader Generic table loading, serialization OMOP Alchemy API OMOP-specific structure &amp; semantics Validation Domain and semantic checks Analytics Queries, cohorts, exploration"},{"location":"api/architecture/","title":"Layered Architecture","text":"<p>OMOP Alchemy is built as a deliberately layered system.</p> <p>Each layer adds capability while preserving the guarantees of the layer below it. Responsibilities flow downward; semantic intent flows upward.</p> <p>The result is a system that is:</p> <ul> <li>composable</li> <li>inspectable</li> <li>safe for both ETL and analytics</li> </ul>"},{"location":"api/architecture/#the-layer-stack","title":"The Layer Stack","text":"flowchart TD     subgraph L0[\"orm-loader\"]         L0a[\"CSVLoadableTableInterface\"]         L0b[\"SerialisableTableInterface\"]         L0c[\"Bulk load &amp; casting helpers\"]     end      subgraph L1[\"cdm.base\"]         L1a[\"CDMTableBase\"]         L1b[\"Column helpers\"]         L1c[\"Structural mixins\"]         L1d[\"ReferenceContext\"]         L1e[\"DomainValidation primitives\"]     end      subgraph L2[\"cdm.models\"]         L2a[\"Concrete CDM tables\"]         L2b[\"@cdm_table\"]         L2c[\"OMOP-compliant schemas\"]     end      subgraph L3[\"Views &amp; Contexts\"]         L3a[\"Reference contexts\"]         L3b[\"Derived properties\"]         L3c[\"Hybrid expressions\"]     end      subgraph L4[\"Semantic Validation\"]         L4a[\"ExpectedDomain\"]         L4b[\"DomainRule\"]         L4c[\"Runtime domain checks\"]     end      L0 --&gt; L1     L1 --&gt; L2     L2 --&gt; L3     L3 --&gt; L4"},{"location":"api/architecture/#layer-responsibilities","title":"Layer responsibilities","text":""},{"location":"api/architecture/#orm-loader-l0","title":"orm-loader (L0)","text":"<p>Purpose: ingestion and infrastructure</p> <p>This layer provides:</p> <ul> <li>CSV loading</li> <li>bulk inserts</li> <li>type casting</li> <li>serialization helpers</li> </ul> <p>It is deliberately domain-agnostic.</p> <p>If something understands OMOP concepts, vocabularies, or clinical meaning, it does not belong here.</p> <p>Examples:</p> <ul> <li>CSVLoadableTableInterface</li> <li>SerialisableTableInterface</li> </ul>"},{"location":"api/architecture/#cdmbase-l1","title":"cdm.base (L1)","text":"<p>Purpose: structural OMOP semantics</p> <p>This layer encodes:</p> <ul> <li>common OMOP table structure</li> <li>column patterns (required vs optional)</li> <li>reusable mixins</li> <li>reference relationship mechanics</li> <li>domain validation primitives</li> </ul> <p>This is where OMOP\u2019s shape lives, but not its analytical meaning.</p> <p>Examples:</p> <ul> <li>CDMTableBase</li> <li>PersonScoped</li> <li>ReferenceContext</li> </ul> <p>This layer answers:</p> <p>\u201cWhat does a valid OMOP table look like?\u201d</p>"},{"location":"api/architecture/#cdmmodels-l2","title":"cdm.models (L2)","text":"<p>Purpose: concrete OMOP tables</p> <p>This layer defines:</p> <ul> <li>actual CDM tables</li> <li>exact column layouts</li> <li>primary keys and foreign keys</li> <li>official OMOP schemas</li> </ul> <p>Classes in this layer:</p> <ul> <li>are safe for ETL</li> <li>are safe for bulk loading</li> <li>avoid eager relationships</li> <li>avoid analytical helpers</li> </ul> <p>Examples:</p> <p>Person</p>"},{"location":"api/architecture/#views-contexts-l3","title":"Views &amp; Contexts (L3)","text":"<p>Purpose: navigation and analysis</p> <p>This layer adds:</p> <ul> <li>reference relationships</li> <li>derived properties</li> <li>hybrid expressions</li> <li>query-friendly helpers</li> </ul> <p>Examples:</p> <p>PersonContext PersonView</p> <p>Views are designed for interactive use, not ingestion.</p> <p>Tables are for pipelines. Views are for people.</p>"},{"location":"api/architecture/#semantic-validation-l4","title":"Semantic Validation (L4)","text":"<p>Purpose: make semantic expectations explicit</p> <p>This layer introduces:</p> <ul> <li>declared domain expectations</li> <li>inspectable rules</li> <li>runtime, advisory checks</li> </ul> <p>Examples:</p> <p>ExpectedDomain</p> <p>This layer answers:</p> <p>\u201cDoes this object reference the kinds of concepts I think it does?\u201d</p> <p>Validation here is:</p> <ul> <li>non-blocking</li> <li>non-mutating</li> <li>safe to skip</li> <li>safe to run interactively</li> </ul>"},{"location":"api/architecture/#directional-guarantees","title":"Directional guarantees","text":"<p>The stack is intentionally one-directional:</p> <ul> <li>lower layers never import higher layers</li> <li>ETL code never depends on analytical helpers</li> <li>validation never mutates state</li> </ul> <p>This guarantees:</p> <ul> <li>predictable ingestion</li> <li>expressive analysis</li> <li>minimal coupling</li> <li>documentation that stays aligned with code</li> </ul>"},{"location":"api/architecture/#why-this-separation-matters","title":"Why this separation matters","text":"<p>Implementations that collapse these concerns into a single ORM layer will tend to produce:</p> <ul> <li>accidental joins in ETL</li> <li>brittle analytical code</li> <li>hard-to-debug semantics</li> <li>documentation drift</li> </ul>"},{"location":"api/base/","title":"Base Tables","text":"<p>Base tables define the foundation of all concrete OMOP CDM models in OMOP Alchemy.</p> <p>They establish the minimum structural and behavioral contract that distinguishes a real CDM table from:</p> <ul> <li>mixins</li> <li>views</li> <li>derived or analytical constructs</li> </ul> <p>If you are authoring a new OMOP table, this is the layer you inherit from.</p>"},{"location":"api/base/#what-a-base-table-means-here","title":"What a \u201cbase table\u201d means here","text":"<p>In OMOP Alchemy, a base table is:</p> <ul> <li>a concrete SQLAlchemy declarative class</li> <li>representing a real OMOP CDM table</li> <li>safe to load from CSV</li> <li>safe to serialize</li> <li>safe to validate structurally</li> </ul> <p>It is not responsible for:</p> <ul> <li>analytics</li> <li>domain semantics</li> <li>cohort logic</li> <li>query patterns</li> </ul> <p>Those concerns live elsewhere.</p>"},{"location":"api/base/#relationship-to-orm-loader","title":"Relationship to <code>orm-loader</code>","text":"<p><code>CDMTableBase</code> builds directly on infrastructure provided by <code>orm-loader</code>.</p> <p>Specifically, it inherits:</p> <ul> <li><code>CSVLoadableTableInterface</code> \u2014 controlled CSV ingestion</li> <li><code>SerialisableTableInterface</code> \u2014 safe object serialization</li> </ul> <p>This separation is intentional:</p> Layer Responsibility orm-loader Generic ORM loading &amp; serialization OMOP Alchemy OMOP-specific structure &amp; semantics <p><code>CDMTableBase</code> is where those two layers meet.</p>"},{"location":"api/base/#cdmtablebase","title":"<code>CDMTableBase</code>","text":"<p>The <code>CDMTableBase</code> class is the common ancestor for all concrete OMOP CDM tables.</p> <p>               Bases: <code>CSVLoadableTableInterface</code>, <code>SerialisableTableInterface</code></p> <p>Base class for CDM tables that support CSV loading and validation.</p>"},{"location":"api/base/#omop_alchemy.cdm.base.cdm_table_base.CDMTableBase.__abstract__","title":"__abstract__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__abstract__ = True\n</code></pre> <p>Adds structural validation of ORM models against the official OMOP CDM CSV specifications.</p>"},{"location":"api/base/#design-notes","title":"Design notes","text":""},{"location":"api/base/#abstract-by-default","title":"Abstract by default","text":"<p><code>CDMTableBase</code> is declared as abstract:</p> <pre><code>__abstract__ = True\n</code></pre> <p>This ensures it is never mapped on its own and is only used as a structural parent.</p> <p>Concrete tables must explicitly opt in (via <code>@cdm_table</code>). The @cdm_table marker makes intent explicit:</p> <p>\u201cThis class represents a real, concrete OMOP CDM table.\u201d</p> <p>Tooling, validation, and documentation can then rely on that signal without guessing based on inheritance structure.</p>"},{"location":"api/base/#structural-validation-hooks","title":"Structural validation hooks","text":"<p>The optional class attribute <code>__cdm_extra_checks__: list[str]</code> exists to support table-specific structural validation against the OMOP CDM CSV specifications.</p> <p>At present:</p> <ul> <li>it is informational</li> <li>it documents known structural constraints</li> <li>it does not trigger automatic checks</li> </ul> <p>This hook exists to keep structural intent co-located with the model, even when enforcement is deferred.</p>"},{"location":"api/base/#minimal-runtime-helpers","title":"Minimal runtime helpers","text":"<p>CDMTableBase intentionally provides very little behavior.</p> <p>The only built-in helper is <code>table_has_rows(session)</code> \u2014 a lightweight existence check</p>"},{"location":"api/columns/","title":"Columns &amp; Structural Mixins","text":"<p>OMOP Alchemy provides a small set of column helpers and mixins that encode recurring OMOP CDM patterns directly into ORM structure.</p> <p>These utilities exist to:</p> <ul> <li>reduce boilerplate</li> <li>make OMOP semantics explicit</li> <li>keep table definitions readable</li> <li>align ORM structure with CDM specifications</li> </ul> <p>They are structural, not analytical: they describe how data is shaped, not what it means.</p>"},{"location":"api/columns/#column-helper-functions","title":"Column helper functions","text":"<p>Column helpers wrap common OMOP column patterns into small, intention-revealing factory functions.</p> <p>They are thin wrappers around <code>sqlalchemy.orm.mapped_column</code> with defaults chosen to match the CDM Field-Level specifications.</p>"},{"location":"api/columns/#concept-foreign-keys","title":"Concept foreign keys","text":"<p>OMOP relies heavily on concept identifiers, with specific semantics around nullability and unknown values.</p> <p>required_concept_fk</p> <p>OMOP-required concept foreign key.</p> <p>This pattern is used when the CDM requires a concept reference, but allows an explicit \u201cunknown\u201d value (<code>concept_id = 0</code>).</p> <p>Semantics:</p> <ul> <li>Must exist</li> <li>Unknown allowed (concept_id = 0)</li> <li>Matches CDM Field-Level spec</li> <li>foreign key to <code>concept.concept_id</code></li> </ul> <p>optional_concept_fk</p> <p>Used when a concept reference is genuinely optional.</p>"},{"location":"api/columns/#convenience-wrappers","title":"Convenience wrappers","text":"<p>These helpers exist primarily for consistency and readability when defining large tables with many fields.</p> <p>optional_fk</p> <p>Optional foreign keys to non-concept tables.</p> <p>required_int</p> <p>Required integer column.</p> <p>optional_int</p> <p>Optional integer column.</p>"},{"location":"api/columns/#structural-mixins","title":"Structural mixins","text":"<p>Structural mixins encode table-level OMOP patterns that recur across multiple CDM tables.</p> <p><code>PersonScoped</code></p> <p>Used for tables that are fundamentally scoped to a person.</p> <p>Encodes the standard <code>person_id</code> foreign key and indexing pattern.</p> <p><code>ConceptTyped</code></p> <p>Mixin for tables whose primary meaning is encoded by a concept_id.</p> <p>Subclasses MUST define something_concept_id.</p> <p>Not currently used, but intention to build out logic for generic EAV queries &amp; timeline projections.</p> <p><code>ValueMixin</code></p> <p>Encodes the OMOP pattern where a value may be represented either numerically or categorically.</p> <p>Structural guarantees:</p> <ul> <li>at least one value must be present</li> <li>enforced via a check constraint</li> <li>validated at assignment time</li> </ul> <p>This helps when building generic tooling that needs to handle values flexibly but then normalise for analysis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from omop_alchemy.cdm.model.clinical.measurement import Measurement\n&gt;&gt;&gt; m = Measurement()\n&gt;&gt;&gt; m.value_as_number = 42.0\n&gt;&gt;&gt; m.value_as_concept_id = None  # OK\n&gt;&gt;&gt; m.value_as_number = None  # Raises ValueError\n</code></pre> <p><code>DatedEvent</code></p> <p>Mixin for tables with start/end date and datetime pairs.</p> <p>This mixin does not enforce temporal logic (e.g. start \u2264 end); it only defines the shape, but this may be integrated with the event timeline machinery in future.</p> <p><code>HealthSystemContext</code></p> <p>Encodes attribution to providers and visits.</p> <p>Used across many clinical event tables to provide consistent join points into the health system structure.</p> <p><code>SourceAttribution</code></p> <p>Mixin for _source_value and _source_concept_id patterns.</p> <p><code>UnitConcept</code></p> <p>Mixin for unit_concept_id.</p>"},{"location":"api/columns/#marker-mixins","title":"Marker mixins","text":"<p>Some mixins exist purely to label intent. They do not add columns or behavior. We don't currently do anything with these.</p> <p><code>FactTable</code></p> <p>Marker mixin for OMOP fact tables.</p> <p>Used for introspection, tooling, and documentation only.</p> <p><code>ReferenceTable</code></p> <p>Marker mixin for OMOP reference tables.</p>"},{"location":"api/relationships/","title":"Relationships &amp; Reference Contexts","text":"<p>OMOP Alchemy takes a deliberately conservative approach to ORM relationships.</p> <p>Rather than eagerly wiring every foreign key into a bidirectional relationship, it distinguishes between:</p> <ul> <li>structural foreign keys (always present in tables)</li> <li>reference lookups (read-only joins for navigation)</li> <li>analytical relationships (used in views, not ETL)</li> </ul> <p>This separation keeps core tables simple, predictable, and fast to load, while still enabling rich, expressive navigation when you need it.</p>"},{"location":"api/relationships/#why-relationships-are-handled-carefully","title":"Why relationships are handled carefully","text":"<p>The OMOP CDM has several characteristics that make na\u00efve ORM relationships risky:</p> <ul> <li>very long, mixed-use tables</li> <li>many optional foreign keys</li> <li>polymporphism</li> <li>frequent joins to large vocabulary tables</li> <li>mixed use cases (ETL vs analytics vs inspection)</li> </ul> <p>In particular:</p> <ul> <li>ETL workflows should not accidentally trigger joins</li> <li>reference data should be navigable but not mutable</li> <li>analytical helpers should not pollute base table definitions</li> </ul> <p>OMOP Alchemy addresses this by introducing Reference Contexts.</p> <p><code>ReferenceContext</code> </p> <p>A helper base class for defining read-only reference relationships.</p> <p>This class is purely structural: it resolves foreign keys into reference tables (Domain, Vocabulary, ConceptClass, etc.) with explicit join conditions.</p> <p>These relationships are:</p> <ul> <li><code>viewonly=True</code></li> <li>explicitly joined</li> <li>resolved lazily using <code>selectin</code></li> <li>defined outside the core table</li> </ul> <p>They are intended for:</p> <ul> <li>inspection</li> <li>analytics</li> <li>debugging</li> <li>view-level navigation \u2014 not for ETL or mutation.</li> </ul>"},{"location":"api/relationships/#the-core-idea","title":"The core idea","text":"<p>Instead of defining relationships directly on a table class, OMOP Alchemy encourages a three-layer pattern:</p> <ol> <li>Table \u2013 structural definition only</li> <li>Context \u2013 reference relationships</li> <li>View \u2013 analytical behavior and validation</li> </ol> <p>This keeps concerns cleanly separated.</p>"},{"location":"api/relationships/#worked-example-person","title":"Worked example: <code>Person</code>","text":""},{"location":"api/relationships/#1-the-base-table","title":"1. The base table","text":"<p>The core <code>Person</code> table defines:</p> <ul> <li>primary keys</li> <li>scalar fields</li> <li>foreign key columns</li> <li>no ORM relationships</li> </ul> <pre><code>@cdm_table\nclass Person(CDMTableBase, Base, HealthSystemContext):\n    __tablename__ = \"person\"\n\n    person_id: Mapped[int] = mapped_column(primary_key=True)\n\n    year_of_birth: Mapped[int] = required_int()\n    gender_concept_id: Mapped[int] = required_concept_fk()\n    race_concept_id: Mapped[int] = required_concept_fk()\n    ethnicity_concept_id: Mapped[int] = required_concept_fk()\n\n    location_id: Mapped[Optional[int]] = mapped_column(\n        ForeignKey(\"location.location_id\"),\n        nullable=True,\n        index=True,\n    )\n</code></pre> <p>At this layer:</p> <ul> <li>the table is easy to reason about</li> <li>loading rows never triggers joins</li> <li>nothing is implicitly navigable</li> </ul> <p>This is the class you want in ETL loops.</p>"},{"location":"api/relationships/#2-the-reference-context","title":"2. The reference context","text":"<p>Reference relationships are defined separately in a <code>Context</code> class:</p> <pre><code>class PersonContext(ReferenceContext):\n    gender = ReferenceContext._reference_relationship(\n        target=\"Concept\",\n        local_fk=\"gender_concept_id\",\n        remote_pk=\"concept_id\",\n    )\n\n    location = ReferenceContext._reference_relationship(\n        target=\"Location\",\n        local_fk=\"location_id\",\n        remote_pk=\"location_id\",\n    )\n</code></pre> <p>Key properties of these relationships:</p> <ul> <li>viewonly=True</li> <li>no backrefs</li> <li>explicit join conditions</li> <li>safe to compose</li> </ul>"},{"location":"api/relationships/#3-the-analytical-view","title":"3. The analytical view","text":"<p>Finally, the <code>PersonView</code> composes everything together:</p> <pre><code>class PersonView(Person, PersonContext, DomainValidationMixin):\n    __tablename__ = \"person\"\n    __mapper_args__ = {\"concrete\": False}\n\n    __expected_domains__ = {\n        \"gender_concept_id\": ExpectedDomain(\"Gender\"),\n        \"race_concept_id\": ExpectedDomain(\"Race\"),\n    }\n</code></pre> <p>This is the class you use for:</p> <ul> <li>analytics</li> <li>cohort logic</li> <li>interactive inspection</li> <li>debugging</li> </ul> <p>It is intentionally not the class you use for bulk loading.</p>"},{"location":"api/relationships/#why-reference-relationships-are-view-only","title":"Why reference relationships are view-only","text":"<p>Reference relationships are declared as:</p> <ul> <li><code>viewonly=True</code></li> <li>no cascade rules</li> <li>no persistence semantics</li> </ul> <p>This is intentional.</p> <p>Vocabulary tables (Concept, Domain, Vocabulary, etc.) are:</p> <ul> <li>shared</li> <li>stable</li> <li>not owned by fact tables</li> </ul> <p>Allowing mutation through ORM relationships would blur those boundaries and make ETL behavior harder to reason about.</p>"},{"location":"api/relationships/#performance-considerations","title":"Performance considerations","text":"<p>Reference relationships use <code>lazy=\"selectin\"</code></p> <p>This provides a good balance:</p> <ul> <li>avoids N+1 queries in most cases</li> <li>avoids eager joins during row loading</li> <li>keeps behaviour predictable</li> </ul> <p>If you need tighter control, you can always override loading strategies in queries.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This section introduces the core ideas behind OMOP Alchemy and how to begin using it in your own projects.</p> <p>OMOP Alchemy is designed to be safe to import anywhere and flexible enough to integrate with existing pipelines, research workflows, and analysis environments. These pages cover installation, and a minimal quickstart to orient you.</p>"},{"location":"getting-started/#orientation","title":"Orientation","text":"<ul> <li>Installation</li> <li>Quickstart</li> </ul>"},{"location":"getting-started/installation/","title":"Basic setup","text":""},{"location":"getting-started/installation/#connecting-directly-via-sqlalchemy","title":"Connecting directly via SQLAlchemy","text":"<p>OMOP_Alchemy does not require any special database wrapper. </p> <p>You can always connect to your database using plain SQLAlchemy and work with engines, connections, and sessions exactly as you would in any other project.</p> <pre><code>import sqlalchemy as sa\nimport sqlalchemy.orm as so\nfrom omop_alchemy.cdm.model.vocabulary import Concept\n\nengine = sa.create_engine(\n    \"postgresql+psycopg://user:password@localhost:5432/omop\",\n    future=True,\n    echo=False,\n)\n\nwith so.Session(engine) as sess:\n    concepts = (\n        session.query(Concept)\n        .filter(Concept.domain_id == \"Drug\")\n        .limit(10)\n        .all()\n    )\n</code></pre> <pre><code>with so.Session(engine) as session:\n    session.add(obj)\n    session.commit()\n</code></pre>"},{"location":"getting-started/installation/#connecting-with-omop_alchemy-specific-helpers","title":"Connecting with OMOP_Alchemy-specific helpers","text":""},{"location":"getting-started/installation/#environment-based-config","title":"Environment-based config","text":"<pre><code>def load_environment(dotenv: str = '') -&gt; None:\n</code></pre> <p>Loads environment variables from a .env file into the process environment.</p> <ul> <li>If a specific .env path is provided, it is loaded first</li> <li>Otherwise, a default .env file is searched for</li> </ul> <pre><code>load_environment()\n\nload_environment(\"/etc/myapp/.env\")\n</code></pre>"},{"location":"getting-started/installation/#database-engine-resolution","title":"Database engine resolution","text":"<p><pre><code>def get_engine_name(schema: str | None = None) -&gt; str:\n</code></pre> Resolves a SQLAlchemy database engine URI from environment variables.</p> <p>If a <code>schema</code> is provided, resolution proceeds as follows:</p> <ol> <li><code>ENGINE_&lt;SCHEMA&gt;</code></li> <li><code>ENGINE</code> as fallback (if only one)</li> </ol> <p>Single DB .env example:</p> <pre><code>ENGINE=postgresql+psycopg://user:password@localhost:5432/omop\n\nengine_url = get_engine_name()\n</code></pre> <p>Multi-schema routing</p> <pre><code>ENGINE_CDM=postgresql+psycopg://user:password@localhost:5432/cdm\nENGINE_SOURCE=postgresql+psycopg://user:password@localhost:5432/source\nENGINE=postgresql+psycopg://user:password@localhost:5432/default\n\ncdm_engine = get_engine_name(\"cdm\")\nsource_engine = get_engine_name(\"source\")\ndefault_engine = get_engine_name()\n</code></pre>"},{"location":"getting-started/installation/#recommended-patterns","title":"Recommended patterns","text":"<pre><code>from orm_loader.helpers import configure_logging, bootstrap\nfrom omop_alchemy import get_engine_name, load_environment\nimport sqlalchemy as sa\n\nconfigure_logging()\nload_environment()\n\nengine_string = get_engine_name('cdm')\nengine = sa.create_engine(engine_string, future=True, echo=False)\n\nbootstrap(engine, create=True)\n</code></pre>"},{"location":"getting-started/installation/#session-engine-management-for-bulk-operations","title":"Session &amp; Engine Management for Bulk Operations","text":"<p>ORM-loader module provides context managers for safely relaxing database constraints during high-volume operations such as CSV loads, staging-table merges, and backfills.</p> <p>These utilities temporarily change database behaviour and guarantee restoration even on failure.</p> <p><code>bulk_load_context</code> temporarily adjusts session-level behaviour to make bulk inserts faster:</p> <ul> <li>Optionally disables foreign key enforcement</li> <li>Optionally disables SQLAlchemy autoflush</li> <li>Ensures all settings are restored on exit</li> <li>Rolls back the session if an exception occurs</li> </ul> <p>This context manager is session-scoped and safe to use alongside ORM loaders, and is supported for sqlite and postgres backends.</p> <pre><code>@contextmanager\ndef bulk_load_context(\n    session: Session,\n    *,\n    disable_fk: bool = True,\n    no_autoflush: bool = True,\n):\n</code></pre> <p>Usage:</p> <pre><code>from sqlalchemy.orm import Session\nfrom orm_loader.helpers import bulk_load_context\n\nwith Session(engine) as session:\n    with bulk_load_context(session):\n        MyTable.load_csv(\n            session,\n            path=\"MY_TABLE.csv\",\n            dedupe=True,\n            merge_strategy=\"upsert\",\n        )\n\n    session.commit()\n</code></pre> <p><code>engine_with_replica_role</code> enforces replica mode at the engine level, meaning:</p> <ul> <li>All new connections opened during the context run with <code>session_replication_role = replica</code></li> <li>The role is restored to DEFAULT afterward</li> </ul> <p>This is supported for postgres only.</p> <p>Use engine_with_replica_role when:</p> <ul> <li>Creating / refreshing materialized views</li> <li>Running schema-level operations that might trigger independent sessions</li> <li>Using tooling that opens its own connections</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quickstart (Experimental Docker Stack)","text":"<p>This Docker stack is intended for local experimentation, development, and exploration only. It is not hardened, secured, or tuned for production use.</p> <p>The goal is to provide a fast, reproducible environment for: - Exploring schemas and data - Prototyping ETL / ORM logic - Testing materialized views, loaders, and queries - Running notebooks against a local PostgreSQL instance</p>"},{"location":"getting-started/quickstart/#what-this-stack-provides","title":"What this stack provides","text":"<p>When started with the appropriate profile, this stack runs:</p> <ul> <li>PostgreSQL (<code>cava-database</code>)</li> <li>Custom-built image (see <code>docker/postgres/Dockerfile</code>)</li> <li>Persistent storage via Docker volumes</li> <li>pgAdmin (<code>pgadmin</code>)</li> <li>Web UI for inspecting and querying PostgreSQL</li> <li>JupyterLab (<code>cava-jupyter-notebook</code>, optional)</li> <li>Notebook environment wired to the same database</li> </ul> <p>All services communicate on a dedicated Docker bridge network (<code>cava-network</code>).</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>You\u2019ll need:</p> <ul> <li>Docker Desktop (or Docker Engine + Compose v2)</li> <li><code>docker compose</code> available on your PATH</li> <li>A <code>.env</code> file in the <code>docker/</code> directory</li> </ul>"},{"location":"getting-started/quickstart/#environment-configuration","title":"Environment configuration","text":"<p>Create a <code>.env</code> file alongside <code>docker-compose.yml</code>, for example:</p> <pre><code>POSTGRES_USER=postgres\nPOSTGRES_PASSWORD=postgres\nPOSTGRES_DB=cava\n\nHOST=localhost\nHTTP_TYPE=http\n\nPYTHON_BIND_MOUNT=/absolute/path/to/your/code_or_data\n</code></pre> <p>These credentials are not secure and are intentionally simple for local use.</p>"},{"location":"getting-started/quickstart/#starting-the-stack","title":"Starting the stack","text":"<p>From the <code>docker</code> directory</p>"},{"location":"getting-started/quickstart/#database-pgadmin-only","title":"Database + pgAdmin only","text":"<pre><code>docker compose --profile default up -d\n</code></pre>"},{"location":"getting-started/quickstart/#database-pgadmin-jupyter","title":"Database + pgAdmin + Jupyter","text":"<pre><code>docker compose --profile jupyter up -d\n</code></pre>"},{"location":"models/","title":"OMOP Models","text":"<p>OMOP Alchemy defines ORM models corresponding to the official OMOP CDM tables, organised by clinical and operational domain.</p> <p>Models are fully typed, relationship-aware, and designed for safe querying, validation, and reuse.</p>"},{"location":"models/#clinical-data","title":"Clinical Data","text":"<ul> <li>Person</li> <li>Condition Occurrence</li> <li>Drug Exposure</li> <li>Measurement</li> <li>Observation</li> </ul>"},{"location":"models/#health-system-structure","title":"Health System Structure","text":"<ul> <li>Visit Occurrence</li> <li>Visit Detail</li> <li>Care Site</li> <li>Provider</li> <li>Location</li> </ul>"},{"location":"models/#vocabulary-concepts","title":"Vocabulary &amp; Concepts","text":"<ul> <li>Concept</li> <li>Domain</li> <li>Vocabulary</li> <li>Concept Relationships</li> </ul>"},{"location":"models/#derived-extended-models","title":"Derived &amp; Extended Models","text":"<ul> <li>Condition Era</li> <li>Drug Era</li> <li>Dose Era</li> <li>Cohort &amp; Cohort Definitions</li> </ul>"},{"location":"models/clinical/","title":"clinical Models","text":"<p>This section contains ORM models corresponding to OMOP CDM clinical tables.</p> <p>Each model is fully typed, relationship-aware, and designed for safe analytical and validation workflows.</p>"},{"location":"models/clinical/condition_occurrence/","title":"condition occurrence","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>condition_occurrence</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/clinical/drug_exposure/","title":"drug exposure","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>drug_exposure</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/clinical/measurement/","title":"measurement","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>measurement</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/clinical/observation/","title":"oubservation","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>observation</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/clinical/person/","title":"person","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>person</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/derived/","title":"derived Models","text":"<p>This section contains ORM models corresponding to OMOP CDM derived tables.</p> <p>Each model is fully typed, relationship-aware, and designed for safe analytical and validation workflows.</p>"},{"location":"models/derived/cohort/","title":"cohort","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>cohort</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/derived/condition_era/","title":"condition era","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>condition_era</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/derived/dose_era/","title":"dose era","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>dose_era</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/derived/drug_era/","title":"drug era","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>drug_era</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/health_economic/","title":"health economic Models","text":"<p>This section contains ORM models corresponding to OMOP CDM health economic tables.</p> <p>Models here are fully typed, relationship-aware, and designed for analytical and validation workflows.</p>"},{"location":"models/health_economic/cost/","title":"cost","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>cost</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/health_economic/payer_plan_period/","title":"payer plan period","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>payer_plan_period</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/health_system/","title":"health system Models","text":"<p>This section contains ORM models corresponding to OMOP CDM health system tables.</p> <p>Each model is fully typed, relationship-aware, and designed for safe analytical and validation workflows.</p>"},{"location":"models/health_system/care_site/","title":"care site","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>care_site</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/health_system/location/","title":"location","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>location</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/health_system/provider/","title":"provider","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>provider</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/health_system/visit_detail/","title":"visit detail","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>visit_detail</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/health_system/visit_occurrence/","title":"visit occurrence","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>visit_occurrence</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/metadata/","title":"metadata Models","text":"<p>This section contains ORM models corresponding to OMOP CDM metadata tables.</p> <p>Models here are fully typed, relationship-aware, and designed for analytical and validation workflows.</p>"},{"location":"models/metadata/cdm_source/","title":"cdm source","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>cdm_source</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/metadata/metadata/","title":"metadata","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>metadata</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/structural/","title":"structural Models","text":"<p>This section contains ORM models corresponding to OMOP CDM structural tables.</p> <p>Models here are fully typed, relationship-aware, and designed for analytical and validation workflows.</p>"},{"location":"models/structural/episode/","title":"episode","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>episode</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/structural/episode_event/","title":"episode event","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>episode_event</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/structural/fact_relationship/","title":"fact relationship","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>fact_relationship</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/unstructured/","title":"unstructured Models","text":"<p>This section contains ORM models corresponding to OMOP CDM unstructured tables.</p> <p>Models here are fully typed, relationship-aware, and designed for analytical and validation workflows.</p>"},{"location":"models/unstructured/image/","title":"image","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>image</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/unstructured/image_feature/","title":"image feature","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>image_feature</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/unstructured/note/","title":"note","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>note</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/unstructured/note_nlp/","title":"note nlp","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>note_nlp</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/vocabulary/","title":"vocaubulary Models","text":"<p>This section contains ORM models corresponding to OMOP CDM vocabulary tables.</p> <p>Each model is fully typed, relationship-aware, and designed for safe analytical and validation workflows.</p>"},{"location":"models/vocabulary/concept/","title":"concept","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>concept</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/vocabulary/concept_relationship/","title":"concept relationship","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>concept_relationship</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/vocabulary/domain/","title":"domain","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>domain</code> as implemented in OMOP Alchemy.</p>"},{"location":"models/vocabulary/vocabulary/","title":"vocaubulary","text":"<p>Documentation coming soon.</p> <p>This page will describe the OMOP model <code>vocabulary</code> as implemented in OMOP Alchemy.</p>"},{"location":"validation/","title":"Validation","text":"<p>OMOP Alchemy provides semantic validation utilities for working with OMOP CDM data safely and intentionally.</p> <p>Validation in this context focuses on:</p> <ul> <li>whether OMOP conventions are respected in practice</li> <li>whether analytical views are logically coherent</li> </ul>"},{"location":"validation/#what-lives-here","title":"What lives here","text":"<p>The validation layer covers:</p> <ul> <li>OMOP domain constraints (e.g. gender concepts must be from the Gender domain)</li> <li>Concept-level semantic checks</li> <li>View-scoped expectations</li> <li>Lightweight runtime diagnostics</li> </ul> <p>It distinguishes between structural correctness and semantic correctness.</p> <p>Structural validation (tables, columns, keys, loadability) is handled by lower-level infrastructure in <code>orm-loader</code>.</p>"},{"location":"validation/#structural-vs-semantic-validation","title":"Structural vs semantic validation","text":"Layer Responsibility Database Physical constraints, indexes orm-loader Table structure, keys, loadability, handle dirty and untrusted data sources OMOP Alchemy Meaning, domains, concept semantics <p>This separation ensures:</p> <ul> <li>reusable infrastructure</li> <li>OMOP-specific logic stays OMOP-specific</li> <li>validation can evolve independently of ingestion</li> </ul>"},{"location":"validation/#validation-scope","title":"Validation scope","text":"<p>Currently supported validation includes:</p> <ul> <li>domain conformity checks</li> <li>concept-level sanity checks</li> <li>view-level semantic expectations</li> </ul> <p>Future extensions may include:</p> <ul> <li>value set adherence</li> <li>temporal logic checks</li> <li>cross-table semantic consistency</li> </ul>"},{"location":"validation/#rule-specification-and-documentation","title":"Rule specification and documentation","text":"<p>Domain rules are generated from View classes via collect_domain_rules() rather than being authored manually.</p> <ul> <li>Domain Rules</li> </ul>"},{"location":"validation/#runtime-usage","title":"Runtime usage","text":"<p>Interactive checking of object conformance</p> <ul> <li>Domain Runtime</li> </ul>"},{"location":"validation/domain-rules/","title":"Domain Rules","text":"<p>Domain rules describe expected OMOP concept domains for specific fields on OMOP tables or views.</p> <p>They are represented explicitly using the <code>DomainRule</code> model.</p> <p>These expectations are not enforced by the database and are often not enforced by ETL pipelines \u2014 which is precisely why they need to be documented and validated explicitly.</p>"},{"location":"validation/domain-rules/#declaring-expected-domains","title":"Declaring expected domains","text":"<p>DomainRule</p> <p>Immutable specification of an expected OMOP domain constraint.</p> <p>A DomainRule describes the semantic expectation that a given concept ID field on a table or view should reference concepts from one or more OMOP domains.</p> <p>Domain rules are derived from model declarations and are intended for inspection, documentation, and validation workflows. They do not enforce behavior or mutate data.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>Name of the OMOP table or view the rule applies to.</p> required <code>field</code> <code>str</code> <p>Name of the concept ID field being constrained.</p> required <code>allowed_domains</code> <code>FrozenSet[str]</code> <p>Set of OMOP domains that are considered valid.</p> required <code>allowed_classes</code> <code>Optional[set[str]]</code> <p>Optional restriction to specific concept classes.</p> <code>None</code>"},{"location":"validation/domain-rules/#why-rules-are-generated-not-authored","title":"Why rules are generated, not authored","text":"<p>OMOP Alchemy does not encourage manually writing domain rules.</p> <p>Instead, rules are derived from model declarations to ensure:</p> <ul> <li>rules stay co-located with semantic intent</li> <li>documentation cannot drift from code</li> <li>tooling can introspect expectations automatically</li> </ul> <p>Domain rules are collected from View classes that declare their expectations explicitly.</p>"},{"location":"validation/domain-rules/#the-expecteddomain-model","title":"The ExpectedDomain Model","text":"<p>ExpectedDomain</p> <p>Declares one or more expected OMOP domains for a concept field.</p> <p>ExpectedDomain is used on View classes to express semantic intent.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ExpectedDomain(\"Gender\").domains\nfrozenset({'Gender'})\n&gt;&gt;&gt; ExpectedDomain(\"Race\", \"Ethnicity\").domains\nfrozenset({'Race', 'Ethnicity'})\n</code></pre>"},{"location":"validation/domain-rules/#use-on-view-classes","title":"Use on View Classes","text":"<p>Expected domains are declared on View classes using <code>__expected_domains__</code>.</p> <p>DomainValidationMixin</p> <p>Adds lightweight runtime domain validation to OMOP View classes.</p> <p>This mixin enables best-effort semantic checks that verify whether referenced concept IDs belong to expected OMOP domains.</p> <p>Validation is advisory:</p> <ul> <li>no exceptions are raised</li> <li>no data is mutated</li> <li>detached objects are handled safely</li> </ul> <p>Intended for View classes only.</p> <p>Examples:</p> <p>Specification on a View:</p> <pre><code>&gt;&gt;&gt; class PersonView(Person, DomainValidationMixin):\n&gt;&gt;&gt;    __expected_domains__ = {\n&gt;&gt;&gt;        \"gender_concept_id\": ExpectedDomain(\"Gender\"),\n&gt;&gt;&gt;        \"race_concept_id\": ExpectedDomain(\"Race\"),\n&gt;&gt;&gt;        \"ethnicity_concept_id\": ExpectedDomain(\"Ethnicity\"),\n&gt;&gt;&gt;    }\n</code></pre> <p>Runtime usage:</p> <pre><code>&gt;&gt;&gt; p = session.get(PersonView, 123)\n&gt;&gt;&gt; p.is_domain_valid\nTrue\n</code></pre> <p>Violations can be inspected without raising exceptions:</p> <pre><code>&gt;&gt;&gt; p.domain_violations\n[\"gender_concept_id not in domain(s): ['Gender']\"]\n</code></pre>"},{"location":"validation/domain-rules/#omop_alchemy.cdm.base.domain_validation.DomainValidationMixin.domain_violations","title":"domain_violations  <code>property</code>","text":"<pre><code>domain_violations: list[str]\n</code></pre> <p>Human-readable descriptions of domain violations on this object.</p>"},{"location":"validation/domain-rules/#omop_alchemy.cdm.base.domain_validation.DomainValidationMixin.is_domain_valid","title":"is_domain_valid  <code>property</code>","text":"<pre><code>is_domain_valid: bool\n</code></pre> <p>Whether this object satisfies all declared domain expectations.</p>"},{"location":"validation/domain-rules/#omop_alchemy.cdm.base.domain_validation.DomainValidationMixin.collect_domain_rules","title":"collect_domain_rules  <code>classmethod</code>","text":"<pre><code>collect_domain_rules() -&gt; list[DomainRule]\n</code></pre> <p>Collect declared domain expectations as canonical DomainRule objects.</p> <p>Returns:</p> Type Description <code>list[DomainRule]</code> <p>Domain rules derived from <code>__expected_domains__</code>.</p>"},{"location":"validation/domain-rules/#collecting-rules-programmatically","title":"Collecting rules programmatically","text":"<p>Declared rules can be collected into canonical <code>DomainRule</code> objects:</p> <pre><code>PersonView.collect_domain_rules()\n</code></pre> <p>Which yields:</p> <pre><code>[\n    DomainRule(\n        table=\"person\",\n        field=\"gender_concept_id\",\n        allowed_domains={\"Gender\"},\n    ),\n    DomainRule(\n        table=\"person\",\n        field=\"race_concept_id\",\n        allowed_domains={\"Race\"},\n    ),\n]\n</code></pre> <p>This allows domain rules to be:</p> <ul> <li>documented</li> <li>audited</li> <li>exported</li> <li>validated across the model layer</li> </ul>"},{"location":"validation/domain-rules/#what-domain-rules-are-not","title":"What domain rules are not","text":"<p>Domain rules intentionally do not:</p> <ul> <li>enforce ETL behavior</li> <li>mutate data</li> <li>raise hard exceptions</li> <li>assume any execution environment</li> </ul> <p>They exist to make semantic expectations visible and checkable \u2014 not to constrain ingestion workflows.</p>"},{"location":"validation/domain-runtime/","title":"Domain Runtime Validation","text":"<p>Runtime domain validation provides best-effort semantic checks on OMOP objects during interactive or analytical use.</p> <p>These checks answer a simple but critical question:</p> <p>\u201cDoes this object reference concepts from the domains it claims to?\u201d</p>"},{"location":"validation/domain-runtime/#domain-validation-is-advisory","title":"Domain validation is advisory","text":"<p>Runtime validation in OMOP Alchemy is:</p> <ul> <li>non-blocking</li> <li>non-mutating</li> <li>safe to run interactively</li> <li>safe to skip entirely</li> </ul> <p>It is designed to surface issues, not enforce policy.</p> <p>This makes it suitable for:</p> <ul> <li>notebooks</li> <li>exploratory analysis</li> <li>cohort debugging</li> <li>governance and QA workflows</li> </ul>"},{"location":"validation/domain-runtime/#domainvalidationmixin","title":"<code>DomainValidationMixin</code>","text":"<p>Domain runtime validation is provided via <code>DomainValidationMixin</code>, which is intended for View classes only.</p> <p>DomainValidationMixin</p> <p>Adds lightweight runtime domain validation to OMOP View classes.</p> <p>This mixin enables best-effort semantic checks that verify whether referenced concept IDs belong to expected OMOP domains.</p> <p>Validation is advisory:</p> <ul> <li>no exceptions are raised</li> <li>no data is mutated</li> <li>detached objects are handled safely</li> </ul> <p>Intended for View classes only.</p> <p>Examples:</p> <p>Specification on a View:</p> <pre><code>&gt;&gt;&gt; class PersonView(Person, DomainValidationMixin):\n&gt;&gt;&gt;    __expected_domains__ = {\n&gt;&gt;&gt;        \"gender_concept_id\": ExpectedDomain(\"Gender\"),\n&gt;&gt;&gt;        \"race_concept_id\": ExpectedDomain(\"Race\"),\n&gt;&gt;&gt;        \"ethnicity_concept_id\": ExpectedDomain(\"Ethnicity\"),\n&gt;&gt;&gt;    }\n</code></pre> <p>Runtime usage:</p> <pre><code>&gt;&gt;&gt; p = session.get(PersonView, 123)\n&gt;&gt;&gt; p.is_domain_valid\nTrue\n</code></pre> <p>Violations can be inspected without raising exceptions:</p> <pre><code>&gt;&gt;&gt; p.domain_violations\n[\"gender_concept_id not in domain(s): ['Gender']\"]\n</code></pre> <p>The mixin relies on:</p> <ul> <li>declared expectations</li> <li>an active SQLAlchemy session (if available)</li> <li>the OMOP <code>Concept</code> table</li> </ul>"},{"location":"validation/domain-runtime/#omop_alchemy.cdm.base.domain_validation.DomainValidationMixin.domain_violations","title":"domain_violations  <code>property</code>","text":"<pre><code>domain_violations: list[str]\n</code></pre> <p>Human-readable descriptions of domain violations on this object.</p>"},{"location":"validation/domain-runtime/#omop_alchemy.cdm.base.domain_validation.DomainValidationMixin.is_domain_valid","title":"is_domain_valid  <code>property</code>","text":"<pre><code>is_domain_valid: bool\n</code></pre> <p>Whether this object satisfies all declared domain expectations.</p>"},{"location":"validation/domain-runtime/#omop_alchemy.cdm.base.domain_validation.DomainValidationMixin.collect_domain_rules","title":"collect_domain_rules  <code>classmethod</code>","text":"<pre><code>collect_domain_rules() -&gt; list[DomainRule]\n</code></pre> <p>Collect declared domain expectations as canonical DomainRule objects.</p> <p>Returns:</p> Type Description <code>list[DomainRule]</code> <p>Domain rules derived from <code>__expected_domains__</code>.</p>"},{"location":"validation/domain-runtime/#runtime-checking-behavior","title":"Runtime checking behavior","text":"<p>At runtime, domain validation:</p> <ul> <li>resolves referenced concept IDs</li> <li>checks their <code>domain_id</code></li> <li>compares against expected domains</li> <li>reports violations as human-readable messages</li> </ul> <p>OMOP conventions are respected:</p> <ul> <li><code>concept_id = 0</code> is always treated as valid</li> <li>detached objects are handled safely</li> </ul>"},{"location":"validation/domain-runtime/#example-usage","title":"Example usage","text":"<pre><code>p = session.get(PersonView, 123)\n\np.is_domain_valid\n</code></pre> <p>Returns <code>True</code> or <code>False</code>.</p> <p>To inspect violations directly:</p> <pre><code>p.domain_violations\n</code></pre> <p>Example output:</p> <pre><code>[\n  \"gender_concept_id not in domain(s): ['Gender']\"\n]\n</code></pre>"},{"location":"validation/domain-runtime/#what-happens-under-the-hood","title":"What happens under the hood","text":"<p>For each declared field:</p> <ol> <li>The referenced <code>concept_id</code> is retrieved</li> <li>The corresponding Concept row is resolved</li> <li>The concept\u2019s <code>domain_id</code> is compared</li> <li>Violations are accumulated, not raised</li> </ol>"},{"location":"validation/domain-runtime/#when-not-to-use-runtime-validation","title":"When not to use runtime validation","text":"<p>Runtime validation is not a substitute for:</p> <ul> <li>ETL quality checks</li> <li>database constraints</li> <li>DataQualityDashboard or similar systematic QA tooling</li> </ul> <p>Those tools operate at a different layer, with different goals. It complements those tools by operating at the model and object layer.</p> <p>\u201cDoes this object, in this analytical context, behave the way I think it does?\u201d</p> <p>That\u2019s a much more local question, and one that usually arises:</p> <ul> <li>during exploration</li> <li>while building derived views</li> <li>or when debugging unexpected analytical results</li> </ul> <p>i.e. not asking whether the database as a whole is valid but trying to understand whether the meaning of what you\u2019re looking at holds.</p>"},{"location":"validation/domain-runtime/#why-an-object-level-approach-helps","title":"Why an object-level approach helps","text":"<p>Many semantic problems don\u2019t show up cleanly in ETL or database checks:</p> <ul> <li>a view joins concept IDs that are technically valid but conceptually incompatible</li> <li>a derived cohort quietly mixes domains in a way that undermines interpretation</li> <li>a field is populated, but with concepts that don\u2019t make sense for this specific use</li> </ul> <p>Custom DQD checks expressed in SQL can handle these local constraints requiring additional context, however these issues are often easiest to spot when you\u2019re already holding the data in your hands. Runtime validation takes advantage of object mappings to support that task by making expectations explicit and inspectable.</p> <ul> <li>DQD establishes baseline trust in the dataset</li> <li>OMOP Alchemy helps maintain semantic clarity during analytical work</li> </ul>"},{"location":"validation/domain-runtime/#next-steps","title":"Next steps","text":"<p>...come back soon for LinkML support</p>"}]}